package org.vaadin.crudui.crud.impl;

import com.vaadin.data.Binder;
import com.vaadin.data.HasValue;
import com.vaadin.icons.VaadinIcons;
import com.vaadin.ui.AbstractOrderedLayout;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.Grid;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.Window;
import com.vaadin.ui.components.grid.Editor;
import com.vaadin.ui.themes.ValoTheme;
import org.vaadin.crudui.crud.CrudListener;
import org.vaadin.crudui.crud.CrudOperation;
import org.vaadin.crudui.form.AbstractAutoGeneratedCrudFormFactory;
import org.vaadin.crudui.form.CrudFormConfiguration;
import org.vaadin.crudui.layout.CrudLayout;
import org.vaadin.crudui.layout.impl.WindowBasedCrudLayout;

import java.util.List;

/**
 * @author Alejandro Duarte
 */
public class EditableGridCrud<T> extends GridCrud<T> {

    protected Editor<T> editor;

    public class GridOnlyCrudFormFactory<T> extends AbstractAutoGeneratedCrudFormFactory<T> {
        public GridOnlyCrudFormFactory(Class<T> domainType) {
            super(domainType);
        }

        @Override
        public AbstractOrderedLayout buildNewForm(CrudOperation operation, T domainObject, boolean readOnly, Button.ClickListener cancelButtonClickListener, Button.ClickListener operationButtonClickListener) {
            throw new UnsupportedOperationException("Building forms is not supported. Grid.Editor is used instead.");
        }

        @Override
        public List<HasValue> buildFields(CrudOperation operation, T domainObject, boolean readOnly) {
            return super.buildFields(operation, domainObject, readOnly);
        }

        @Override
        public CrudFormConfiguration getConfiguration(CrudOperation operation) {
            return super.getConfiguration(operation);
        }

        public Binder<T> getBinder() {
            return binder;
        }
    }

    public EditableGridCrud(Class<T> domainType) {
        this(domainType, new WindowBasedCrudLayout(), null);
    }

    public EditableGridCrud(Class<T> domainType, CrudLayout crudLayout) {
        this(domainType, crudLayout, null);
    }

    public EditableGridCrud(Class<T> domainType, CrudListener<T> crudListener) {
        this(domainType, new WindowBasedCrudLayout(), crudListener);
    }

    public EditableGridCrud(Class<T> domainType, CrudLayout crudLayout, CrudListener<T> crudListener) {
        super(domainType, crudLayout, null, crudListener);
        crudFormFactory = new GridOnlyCrudFormFactory<>(domainType);
        setAddOperationVisible(false);
        setUpdateOperationVisible(false);
    }

    @Override
    public void attach() {
        super.attach();
        configureEditor();
    }

    protected void configureEditor() {
        try {
            getCrudFormFactory().buildFields(CrudOperation.UPDATE, domainType.newInstance(), false);
            editor = grid.getEditor();
            editor.setEnabled(true);
            editor.addSaveListener(e -> {
                try {
                    T updatedObject = updateOperation.perform(e.getBean());
                    refreshGrid();
                    if (items.contains(updatedObject)) {
                        grid.asSingleSelect().setValue(updatedObject);
                        // TODO: grid.scrollTo(updatedObject);
                    }
                    Notification.show(savedMessage);
                } catch (Exception ex) {
                    crudFormFactory.showError(CrudOperation.UPDATE, ex);
                }
            });

            Binder<T> binder = getCrudFormFactory().getBinder();
            editor.setBinder(binder);

            List<String> properties = getCrudFormFactory().getConfiguration(CrudOperation.UPDATE).getVisibleProperties();

            for (String property : properties) {
                Grid.Column<T, ?> column = grid.getColumn(property);
                Binder.Binding<T, ?> binding = binder.getBinding(property).get();
                column.setEditorBinding(binding);
            }
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void gridSelectionChanged() {
        updateButtons();
    }

    @Override
    protected void addButtonClicked() {
        // TODO: https://github.com/vaadin/framework/pull/10040
    }

    @Override
    protected void updateButtonClicked() {
        // TODO: https://github.com/vaadin/framework/pull/10040
    }

    @Override
    protected void deleteButtonClicked() {
        Button cancel = new Button("Cancel");
        Button delete = new Button("Delete", VaadinIcons.TRASH);
        Label label = new Label("Do you really want to delete the selected item?");

        delete.addStyleName(ValoTheme.BUTTON_DANGER);
        HorizontalLayout buttons = new HorizontalLayout(cancel, delete);

        VerticalLayout layout = new VerticalLayout(label, buttons);
        layout.setComponentAlignment(buttons, Alignment.BOTTOM_RIGHT);

        Window window = new Window("Confirm", layout);
        window.setModal(true);
        getUI().addWindow(window);

        cancel.addClickListener(e -> window.close());

        delete.addClickListener(e -> {
            try {
                deleteOperation.perform(grid.asSingleSelect().getValue());
                window.close();
                refreshGrid();
                grid.asSingleSelect().clear();
                Notification.show(deletedMessage);

            } catch (Exception ex) {
                getCrudFormFactory().showError(CrudOperation.DELETE, ex);
            }
        });
    }

    @Override
    public GridOnlyCrudFormFactory<T> getCrudFormFactory() {
        return (GridOnlyCrudFormFactory<T>) super.getCrudFormFactory();
    }

}
